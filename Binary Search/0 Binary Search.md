## Introduction
二分查找又称`折半搜索算法`。
- 狭义上，二分查找是一种在有序数组查找某一特定元素的搜索算法。
- 广义上，二分查找是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3。
> 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳

### 解空间
解空间是**题目所有可能的解构成的集合**. 比如: 一个数组 nums 中查找 target，如果存在则返回对应索引，如果不存在则返回 -1。则解空间是区间 \[-1, n-1\]之间的整数，其中 n 为 nums 的长度。

解可能是其中一个值，我们的目标就是在某个具体的情况判断其具体是哪个。

注意，有的解空间可能包括小数。比如Sqrt(x)。这时候的思路是一样的，两个细节需要变化: 
- 更新答案的步长
- 判断条件时候需要考虑误差

对于**搜索类题目**，解空间一定是有限的，不然问题不可解。对于搜索类问题，第一步就是需要明确解空间，这样你才能够在解空间内进行搜索。

定义解空间的原则: **可大不可小**

### 序列有序
序列可能是数组、链表、或其他数据结构。二分题目大多有**有序**的特征: 
- 有的题目直接点明了有序
- 有的则需要自己构造有序序列。难度较大。比如题目给了数组 nums，没有限定 nums 有序，但限定了 num 为非负。这样如果给 nums 做前缀和或者前缀或（位运算或），就可以得到一个有序序列。比如[[Triple Inversion]]

### 极值
极值指的是**求第 k 大（或者第 k 小）的数**。
> 求第k大一般用堆或二分。

见例子[[Kth Pair Distance]]

## 一个中心
**解空间的折半**

比如刚开始解空间是 \[1, n\]（n 为一个大于 n 的整数）。通过**某种方式**，我们确定 \[1, m\] 区间都**不可能是答案**。那么解空间就变成了 (m,n\]，持续此过程知道解空间变成平凡（直接可解）。

显然折半的难点是**根据什么条件舍弃哪一步部分**。这里有两个关键字:
1.  什么条件
2.  舍弃哪部分

几乎所有的二分的难点都在这两个点上。如果明确了这两点，几乎所有的二分问题都可以迎刃而解。幸运的是，关于这两个问题的答案通常都是有限的，题目考察的往往就是那几种。这其实就是所谓的做题套路。关于这些套路，我会在之后的四个应用部分给大家做详细介绍。

## 两种类型
### 问题定义
给定一个由数字组成的有序数组 nums和一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。

数组是有序的（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）。这个有序的数组可能是题目直接给的，也可能是你自己构造的。比如求数组的逆序数就可以在自己构造的有序序列上做二分。

这是二分查找中最简单的一种形式。当然二分查找也有**很多的变形**，这也是二分查找容易出错，难以掌握的原因。

常见变体有：
-   如果存在多个满足条件的元素，返回最左边满足条件的索引。
-   如果存在多个满足条件的元素，返回最右边满足条件的索引。
-   数组不是整体有序的。 比如先升序再降序，或者先降序再升序。
-   将一维数组变成二维数组。

二分查找中使用的术语：
-   target —— 要查找的值
-   index —— 当前位置
-   l 和 r —— 左右指针
-   mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引（其实就是收缩解空间）
-   除了 target 是固定不变的，其他都是动态变化的。其中 l 和 r 指的是解空间的上下界，mid 是上下界的中间值， index 是遍历指针，用于控制遍历过程。