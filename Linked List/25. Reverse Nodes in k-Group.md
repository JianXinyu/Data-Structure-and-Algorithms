![[24. Swap Nodes in Pairs K1.png]]
比如k=3. 3个一组，组内逆转，对外这一组就相当于首尾两个节点，将这两个节点和其他节点正确连接即可。
![[24. Swap Nodes in Pairs K2.png]]
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode dummy(0);
        dummy.next = head;
        ListNode *prev = &dummy;
     
        int k = 3;
        int n = (k - 1);
        ListNode *cur2 = cur1;
        while(n-- > 0) cur2 = cur2->next;
        
        ListNode *ans = cur2;
        while(cur1 && cur1->next){
            ListNode *next = cur2->next;
            cur2->next = nullptr;
            
            prev->next = cur2;
            inverse(cur1);
            
            prev = cur1;
            cur1 = next;
            n = (k - 1);
            cur2 = cur1;
            while(n-- > 0 && cur2) cur2 = cur2->next;
        }
        return ans;
    }
private:
    ListNode* inverse(ListNode *head){
        if(!head || !head->next) return head;
        ListNode *prev = nullptr, *curr = head, *next;
        while(curr){
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev; 
    }
};
```

```cpp
ListNode *reverseKGroup(ListNode *head, int k) {
	if (!head || k == 1) return head;
	ListNode dummy(0);
	dummy.next = head;
	int len = 1;
	while (head = head->next) len++;
	ListNode* pre = &dummy;    
	for (int l = 0; l + k <= len; l += k) {
	  ListNode* cur = pre->next;
	  ListNode* nxt = cur->next;
	  for (int i = 1; i < k; ++i) {
		cur->next = nxt->next;
		nxt->next = pre->next;
		pre->next = nxt;
		nxt = cur->next;
	  }
	  pre = cur;
	}
	return dummy.next;
}
```
