- if the current range $[l, r]$ is sorted, reduce to the normal binary search
- otherwise, determine the range to search next by comparing target and $nums[0]$. 二分法需要一个mid point，而整个数组又被分成两部分，那么mid和target所处的位置就有四种情况：
	- 在一个区间
		- 同在第一个 $nums[m]>=nums[0] && target>=nums[0]$
		- 同在第二个 $nums[m]<nums[0] && target<nums[0]$
	- 不在一个区间
		- target在第一个区间 $target>=nums[0]$, 移动r
		- target在第二个区间 $target<nums[0]$, 移动l
![[33.png]]

```cpp

	class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size();
        while (l < r) {
            int m = l + ((r-l) >> 1);
            int x = (nums[m] < nums[0]) == (target < nums[0]) 
                    ? nums[m]
                    : target < nums[0] ? INT_MIN : INT_MAX;
            if (x < target)
                l = m + 1;
            else if (x > target)
                r = m;
            else
                return m; 
        }
        return -1;

    }

};
```