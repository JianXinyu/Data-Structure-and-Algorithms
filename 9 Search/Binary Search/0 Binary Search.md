## Introduction
二分查找又称`折半搜索算法`。
- 狭义上，二分查找是一种在有序数组查找某一特定元素的搜索算法。
- 广义上，二分查找是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3。
> 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳

### 解空间
解空间是**题目所有可能的解构成的集合**. 比如: 一个数组 nums 中查找 target，如果存在则返回对应索引，如果不存在则返回 -1。则解空间是区间 \[-1, n-1\]之间的整数，其中 n 为 nums 的长度。

解可能是其中一个值，我们的目标就是在某个具体的情况判断其具体是哪个。

注意，有的解空间可能包括小数。比如Sqrt(x)。这时候的思路是一样的，两个细节需要变化: 
- 更新答案的步长
- 判断条件时候需要考虑误差

对于**搜索类题目**，解空间一定是有限的，不然问题不可解。对于搜索类问题，第一步就是需要明确解空间，这样你才能够在解空间内进行搜索。

定义解空间的原则: **可大不可小**

### 序列有序
序列可能是数组、链表、或其他数据结构。二分题目大多有**有序**的特征: 
- 有的题目直接点明了有序
- 有的则需要自己构造有序序列。难度较大。比如题目给了数组 nums，没有限定 nums 有序，但限定了 num 为非负。这样如果给 nums 做前缀和或者前缀或（位运算或），就可以得到一个有序序列。比如[[Triple Inversion]]

### 极值
极值指的是**求第 k 大（或者第 k 小）的数**。
> 求第k大一般用堆或二分。

见例子[[Kth Pair Distance]]

## 一个中心
**解空间的折半**

对于二分题目首先要明确解空间，然后根据一定条件（通常是和中间值比较），舍弃其中一半的解。

比如刚开始解空间是 \[1, n\]（n 为一个大于 n 的整数）。通过**某种方式**，我们确定 \[1, m\] 区间都**不可能是答案**。那么解空间就变成了 (m,n\]，持续此过程知道解空间变成平凡（直接可解）。

显然折半的难点是**根据什么条件舍弃哪一步部分**:
1.  什么条件
2.  舍弃哪部分

## 两种类型
- 寻找最左插入位置
- 寻找最右插入位置
### 定义问题
给定一个由数字组成的有序数组 nums和一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。

数组是有序的（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）。这个有序的数组可能是题目直接给的，也可能是你自己构造的。比如求数组的逆序数就可以在自己构造的有序序列上做二分。

这是二分查找中最简单的一种形式。当然二分查找也有**很多的变形**，这也是二分查找容易出错，难以掌握的原因。

常见变体有：
-   如果存在多个满足条件的元素，返回最左边满足条件的索引。
-   如果存在多个满足条件的元素，返回最右边满足条件的索引。
-   数组不是整体有序的。 比如先升序再降序，或者先降序再升序。[[33. Search in Rotated Sorted Array]]
-   将一维数组变成二维数组。

二分查找中使用的术语：
-   target —— 要查找的值
-   index —— 当前位置
-   l 和 r —— 左右指针
-   mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引（其实就是收缩解空间）
-   除了 target 是固定不变的，其他都是动态变化的。其中 l 和 r 指的是解空间的上下界，mid 是上下界的中间值， index 是遍历指针，用于控制遍历过程。

### 分析和求解
定义好问题之后，接下来就要对问题分析和求解。

#### 寻找满足条件的值
先从最简单的类型开始分析:查找某一个具体值。

**算法描述**：
-   先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
-   如果目标元素大于中间元素，那么数组中小于中间元素的值都可以排除（由于数组有序，那么相当于是可以排除数组左侧的所有值），解空间可以收缩为 \[mid+1, r\]；
-   如果目标元素小于中间元素，那么数组中大于中间元素的值都可以排除（由于数组有序，那么相当于是可以排除数组右侧的所有值），解空间可以收缩为 \[l, mid - 1\]；
-   如果在某一步骤解空间为空，则代表找不到。

**Complexity Analysis:**
-   平均时间复杂度： O(logN)
-   最坏时间复杂度： O(logN)
-   空间复杂度
    -   迭代: O(1)
    -   递归: O(logN)（无尾调用消除）

**思维框架**:
1. 首先定义解空间为 \[left, right\]，注意是左右都闭合。因此当 left <= right 的时候，解空间都不为空，继续搜索。 i.e., 终止搜索条件应该为 left > right。

3. 循环体内，计算 mid ，并将 nums\[mid\] 与 target 比对。
	-  nums\[mid\] == target， 则提前返回 mid（只需要找到一个满足条件的即可）
    -  nums\[mid\] < target， 说明目标值在 mid 右侧，这个时候解空间可缩小为 \[mid + 1, right\]（mid 以及 mid 左侧的数字被排除）
    -  nums\[mid\] > target， 说明目标值在 mid 左侧，这个时候解空间可缩小为 \[left, mid - 1\] （mid 以及 mid 右侧的数字被排除）

4. 循环结束未找到，返回-1。

**Code template**
```python
def binarySearch(nums, target):
    # 左右都闭合的区间 [l, r]
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (left + right) >> 1
        if nums[mid] == target: return mid
        # 解空间变为 [mid+1, right]
        if nums[mid] < target: l = mid + 1
        # 解空间变为 [left, mid - 1]
        if nums[mid] > target: r = mid - 1
    return -1
```

```cpp
int binarySearch(vector<int>& nums, int target){
	if(nums.size() == 0)
		return -1;

	int left = 0, right = nums.size() - 1;
	while(left <= right){
		// 注意优先级！！！
		int mid = left + ((right - left) >> 1); 
		if(nums[mid] == target){ return mid; }
		else if(nums[mid] < target)
			left = mid + 1;
		else
			right = mid - 1;
	}
	return -1;
}
```

#### 寻找最左插入位置
对于`寻找满足条件的值`， 如果找不到，就返回 -1。
如果想返回应该插入的位置，使得插入之后列表仍然有序呢？比如 nums: \[1,3,4\]，target 是 2。应该将其插入（注意不是真的插入）的位置是索引 1 的位置，即 \[1,**2**,3,4\]。因此`寻找最左插入位置`应该返回 1。
如果有多个满足条件的值，返回最左侧的。 比如 nums: \[1,2,2,2,3,4\]，target 是 2，返回 1。

**思维框架**
1. 首先定义解空间为 \[left, right\]，注意是左右都闭合。因此当 left <= right 的时候，解空间都不为空，继续搜索。 i.e., 终止搜索条件应该为 left > right。

2.  循环体内，计算 mid ，并将 nums\[mid\] 与 target 比对。
	- 当 nums\[mid\] >= target，说明找到一个备胎，令 r = mid - 1, 以将 mid 从解空间排除，继续看看有没有更好的备胎。
    - 当 nums\[mid\] < target，说明 mid 不是答案，令 l = mid + 1，从而将 mid 从解空间排除。
  
3. 最后解空间的 l 就是最好的备胎，备胎转正。

**Code template**
```python
def bisect_left(nums, target):
    bisect.bisect_left(nums, target) # api
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (l + r) // 2
        if nums[mid] >= target: r = mid - 1
        else: l = mid + 1
    return l
```

```cpp

```

#### 寻找最右插入位置
基本和`寻找最左插入位置`一样。
**思维框架**
1. 首先定义解空间为 \[left, right\]，注意是左右都闭合。因此当 left <= right 的时候，解空间都不为空，继续搜索。 i.e., 终止搜索条件应该为 left > right。

2.  循环体内，计算 mid ，并将 nums\[mid\] 与 target 比对。
	- 当 nums\[mid\] <= target，说明找到一个备胎，令 l = mid + 1, 以将 mid 从解空间排除，继续看看有没有更好的备胎。
    - 当 nums\[mid\] > target，说明 mid 不是答案，令 r = mid - 1，从而将 mid 从解空间排除。
  
3. 最后解空间的 r 就是最好的备胎，备胎转正。

**Code template**
```python
def bisect_right(nums, target):
    # 内置 api
    bisect.bisect_right(nums, target)
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (l + r) // 2
        if nums[mid] <= target: l = mid + 1 
        else: r = mid - 1
    return r
```


最左插入和最右插入可以结合使用从而求出**有序序列**中和 target 相等的数的个数
```python
nums = \[1,2,2,2,3,4\]  
i = bisect.bisect\_left(nums, 2) # get 1  
j = bisect.bisect\_right(nums, 2) # get 4  
# j - i 就是 nums 中 2 的个数
```
#### 小结
对于二分题目首先要明确解空间，然后根据一定条件（通常是和中间值比较），舍弃其中一半的解。大家可以先从查找满足条件的值的二分入手，进而学习最左和最右二分。同时大家只需要掌握最左和最右二分即可，因为后者功能大于前者。

对于最左和最右二分，简单用两句话总结一下：
1.  最左二分不断收缩右边界，最终返回左边界
2.  最右二分不断收缩左边界，最终返回右边界

# 题目
- [[Amazon OA. Number of Bricks]]
- [[875. Koko Eating Bananas]]